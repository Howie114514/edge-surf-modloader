import { readFileSync, writeFileSync } from "fs";
import path, { resolve } from "path";
import * as parser from "@babel/parser";
import traverse from "@babel/traverse";
import template from "@babel/template";
import {
  ClassDeclaration,
  Declaration,
  EnumDeclaration,
  identifier,
  stringLiteral,
} from "@babel/types";
import grnerate, { generate } from "@babel/generator";

let root = resolve("./untrusted");

let f = readFileSync(path.join(root, "untrusted-o.js")).toString();

const ast = parser.parse(f);

const buildAccessor = template(
  `
parent._handlers[%%name%%](
  new Proxy(
    {},
    {
      get(_, prop) {
        return eval(prop.toString());
      },
      set(_, prop, value) {
        eval(\`\${prop.toString()}=value\`);
        return true;
      },
    },
  ),
  (x) => eval(x),
);`,
  { syntacticPlaceholders: true },
);

traverse(ast, {
  enter(path) {
    path.node.trailingComments?.forEach((c) => {
      let cmd = c.value.split(" ");
      if (cmd[0] == "@inject") {
        path.insertAfter(
          buildAccessor({
            name: stringLiteral(cmd[1]),
          }),
        );
      }
    });
    path.node.leadingComments?.forEach((c) => {
      let cmd = c.value.split(" ");
      if (cmd[0] == "@inject") {
        path.insertBefore(
          buildAccessor({
            name: stringLiteral(cmd[1]),
          }),
        );
      }
    });
  },
});

ast.program.leadingComments = [
  {
    type: "CommentBlock",
    value: `
 * Auto-generated by SurfModLoader
 * https://github.com/Howie114514/edge-surf-modloader
 `,
  },
];

writeFileSync(path.join(root, "untrusted.js"), generate(ast).code);
